#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     MUX,            sensorI2CCustomFastSkipStates)
#pragma config(Sensor, S4,     ProtoBoard,     sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorC,          PullMotor,     tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     RightBack,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     LeftBack,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Arm1,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Arm2,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     CubeLift,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Flag,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     RightFront,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     LeftFront,     tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    Clamp1,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_2,    Clamp2,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    AutoArm,              tServoStandard)
#pragma config(Servo,  srvo_S2_C2_5,    AutoWrist,            tServoStandard)
#pragma config(Servo,  srvo_S2_C2_6,    FlagTwist,            tServoStandard)
#pragma config(Servo,  srvo_S2_C3_1,    Drop,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    IRServo,              tServoStandard)
#pragma config(Servo,  srvo_S2_C3_3,    RightIRServo,         tServoStandard)
#pragma config(Servo,  srvo_S2_C3_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    AlignServo1,          tServoStandard)
#pragma config(Servo,  srvo_S2_C3_6,    AlignServo2,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

const int FLAG_ARM_OUT = 50;
const int FLAG_ARM_IN = 195;
const int FULL_POWER_FORWARD = 100;
const int HALF_POWER_FORWARD = 50;
const int NO_POWER = 0;
const int HALF_POWER_REVERSE = -50;
const int FULL_POWER_REVERSE = -100;
const int FULL_FORWARD_SERVO = 255;
const int FULL_REVERSE_SERVO = 0;
const int STOP_SERVO=128;
const int SLOW_PRIME_POWER = 10;
const int LIFTER_ENCODER_THRESHOLD = 50;
const int JOY_THRESHOLD = 10;
const int SCOOP_UP=20;
const int SCOOP_DOWN=160;
const int SCOOP_LEVEL=120;
const int CLAMP_OPEN=180;
const int CLAMP_DOWN=100;
const int CLAMP_FLUSH=0;

const int ALIGN_1_OUT=212;
const int ALIGN_2_OUT=48;

const int ALIGN_1_IN=58;
const int ALIGN_2_IN=178;

const int ALIGN_1_GRIP=167;
const int ALIGN_2_GRIP=96;

int sign(int num)
{
	if(num<0)
	{
		return  -1;
		} else	{
		return 1;
	}
}

#define leftjoy joystick.joy1_y1*joystick.joy1_y1*100.0/(128.0*128.0)*sign(joystick.joy1_y1)
#define rightjoy joystick.joy1_y2*joystick.joy1_y2*100.0/(128.0*128.0)*sign(joystick.joy1_y2)
#define leftjoy2 joystick.joy2_y1*joystick.joy2_y1*100.0/(128.0*128.0)*sign(joystick.joy2_y1)
#define rightjoy2 joystick.joy2_y2*joystick.joy2_y2*100.0/(128.0*128.0)*sign(joystick.joy2_y2)

typedef struct
{
	bool pressed;
	bool run;
} servobuttons;

typedef enum
{
	btn_X=1,
	btn_A=2,
	btn_B=3,
	btn_Y=4,
	btn_LB=5,
	btn_RB=6,
	btn_LT=7,
	btn_RT=8,
	btn_BACK=9,
	btn_START=10
} joybtn;



void setArm(int speed)
{
	motor[Arm1]=speed;
	motor[Arm2]=speed;
}

void setClamp(int speed)
{
	servo[Clamp1]=speed;
	servo[Clamp2]=FULL_FORWARD_SERVO-speed;
}


void initializeRobot()
{
	servoChangeRate[Drop]=8;
	setClamp(CLAMP_FLUSH);
	servo[Drop]=SCOOP_UP;
	servo[FlagTwist]=FLAG_ARM_IN;
	servo[AlignServo1]=ALIGN_1_IN;
	servo[AlignServo2]=ALIGN_2_IN;
	servo[IRServo]=128;
	servo[RightIRServo]=0;
	servo[AutoArm]=128;
	servo[AutoWrist]=128;
	return;
}

int shift=0;


//raise the flag asynchronously
task raiseFlag()
{
	servo[FlagTwist]=FLAG_ARM_OUT+shift;
	int halt = 0;
	int encOld = 0;
	int encNow = 0;
	nMotorEncoder[Flag]=0;
	motor[Flag]=FULL_POWER_FORWARD;
	wait10Msec(20);
	while(halt<10)
	{
		motor[Flag]=FULL_POWER_FORWARD;
		wait10Msec(5);
		encOld=encNow;
		encNow=nMotorEncoder[Flag];
		//if the flag is spinning freely, it should go faster than LIFTER_ENCODER_THRESHOLD;
		//otherwise, the flag is at the top
		if(abs(encNow-encOld)<LIFTER_ENCODER_THRESHOLD)
		{
			halt++;
		}
	}
	motor[Flag]=FULL_POWER_REVERSE;
	wait10Msec(15);
	motor[Flag]=NO_POWER;
	servo[FlagTwist]=FLAG_ARM_IN;
}

task closeGrip() {
	servo[AlignServo1]=ALIGN_1_IN;
	servo[AlignServo2]=0;
	wait10Msec(35);
	servo[AlignServo2]=ALIGN_2_IN;
}

bool out = true;

task openGrip() {
	if(servo[AlignServo1]!=ALIGN_1_IN&&servo[AlignServo2]!=ALIGN_2_IN){
		servo[AlignServo1]=ALIGN_1_GRIP;
		servo[AlignServo2]=ALIGN_2_GRIP;
		} else {
		out = false;
		servo[AlignServo2]=0;
		wait10Msec(15);
		servo[AlignServo1]=ALIGN_1_OUT;
		wait10Msec(50);
		servo[AlignServo2]=ALIGN_2_OUT;
		out = true;
	}
}

task fixStuff() {
	servo[AlignServo1]=ALIGN_1_GRIP+30;
	servo[AlignServo2]=ALIGN_2_GRIP+30;
	wait10Msec(40);
	servo[AlignServo1]=ALIGN_1_GRIP;
	servo[AlignServo2]=ALIGN_2_GRIP;
}

task main()
{
	servobuttons intake;
	servobuttons flagTurn;
	servobuttons flagLift;
	servobuttons armUp;
	servobuttons slow;
	slow.run=false;
	initializeRobot();
	waitForStart();   // wait for start of tele-op phase
	intake.run=true;
	float mult;
	while (true)
	{

		getJoystickSettings(joystick);

		if(sign(leftjoy)!=sign(rightjoy)){
			mult = .5;
			} else {
			mult = 1;
		}

		if(!slow.run)
		{
			if (abs(leftjoy)>JOY_THRESHOLD)
			{
				motor[LeftFront]=leftjoy*mult;
				motor[LeftBack]=leftjoy*mult;
			}
			else
			{
				motor[LeftFront]=NO_POWER;
				motor[LeftBack]=NO_POWER;
			}
			if (abs(rightjoy)>JOY_THRESHOLD)
			{
				motor[RightFront]=rightjoy*mult;
				motor[RightBack]=rightjoy*mult;
			}
			else
			{
				motor[RightFront]=NO_POWER;
				motor[RightBack]=NO_POWER;
			}
		}
		//slow
		else
		{
			if (abs(leftjoy)>JOY_THRESHOLD)
			{
				motor[RightFront]=-leftjoy*mult*.75;
				motor[RightBack]=-leftjoy*mult*.75;
			}
			else
			{
				motor[RightFront]=NO_POWER;
				motor[RightBack]=NO_POWER;
			}
			if (abs(rightjoy)>JOY_THRESHOLD)
			{
				motor[LeftFront]=-rightjoy*mult*.75;
				motor[LeftBack]=-rightjoy*mult*.75;
			}
			else
			{
				motor[LeftFront]=NO_POWER;
				motor[LeftBack]=NO_POWER;
			}
		}

		if (joy2Btn(2))
		{
			motor[CubeLift]=FULL_POWER_FORWARD;
			}	else if(joy2Btn(4))	{
			motor[CubeLift]=FULL_POWER_REVERSE;
			} else {
			motor[CubeLift]=NO_POWER;
		}

		if((joy1Btn(btn_Y))&&!slow.pressed)
		{
			slow.pressed=true;
			slow.run=!slow.run;
		}
		if(!(joy1Btn(btn_Y)))
		{
			slow.pressed=false;
		}


		//open the flag raiser and spin it slowly for alignment
		if((joy2Btn(btn_LB))&&!flagLift.pressed)
		{
			flagLift.pressed=true;
			if(servo[FlagTwist]==FLAG_ARM_IN)
			{
				flagLift.run=!flagLift.run;
			}
			shift=0;
			servo[FlagTwist]=FLAG_ARM_OUT;
			motor[Flag]=SLOW_PRIME_POWER;
		}
		//else if((joy2Btn(btn_START) && (servo[FlagTwist] == FLAG_ARM_OUT)))
		//{
		//	motor[Flag]=-SLOW_PRIME_POWER;
		//}
		//else if(!(joy2Btn(btn_START)) && (flagLift.pressed))
		//{
		//	motor[Flag]=NO_POWER;
		//	flagLift.pressed = false;
		//}
		//stop spinning the flag raiser for alignment
		else if(!(joy2Btn(btn_LB))&&flagLift.pressed)
		{
			motor[Flag]=NO_POWER;
			flagLift.pressed=false;
		}
		//control raising the flag

		if((joy2Btn(btn_LT))&&!flagTurn.pressed)
		{
			flagTurn.pressed=true;
			flagTurn.run=!flagTurn.run;
			if(flagTurn.run)
			{
				if(servo[FlagTwist]!=FLAG_ARM_IN)
				{
					StartTask(raiseFlag);
				}
				} else {
				StopTask(raiseFlag);
				if(servo[FlagTwist]!=FLAG_ARM_IN)
				{
					motor[Flag]=FULL_POWER_REVERSE;
				}
				wait10Msec(15);
				motor[Flag]=NO_POWER;
			}
		}
		else if(!(joy2Btn(btn_LT))&&flagTurn.pressed)
		{
			flagTurn.pressed=false;
		}

		if(joy2Btn(btn_BACK))
		{
			servo[FlagTwist]=FLAG_ARM_IN;
			StopTask(raiseFlag);
			motor[Flag]=NO_POWER;
		}

		if(joy2Btn(btn_RT)){
			setArm(FULL_POWER_REVERSE);
			} else if (joystick.joy1_TopHat==5) {
			armUp.run=false;
			setArm(FULL_POWER_REVERSE);
			} else if(joy2Btn(btn_RB)){
			setArm(FULL_POWER_FORWARD);
			} else if(joystick.joy1_TopHat==1) {
			setArm(FULL_POWER_FORWARD);
			} else {
			setArm(NO_POWER);
		}

		if(abs(leftjoy2)>JOY_THRESHOLD){
			motor[PullMotor]=leftjoy2;
			} else {
			motor[PullMotor]=NO_POWER;
		}

		if(joystick.joy1_TopHat==0)
		{
			servo[Drop]=SCOOP_UP;
			setClamp(CLAMP_DOWN);
			} else if (joystick.joy1_TopHat==4) {
			servo[Drop]=SCOOP_DOWN;
			} else if (joystick.joy1_TopHat==2 || joystick.joy1_TopHat==6) {
			servo[Drop]=SCOOP_LEVEL;
			setClamp(CLAMP_OPEN);
			} else if (joystick.joy2_TopHat==0) {
			servo[Drop]=servo[Drop]-1;
			wait10Msec(1);
			} else if (joystick.joy2_TopHat==4) {
			servo[Drop]=servo[Drop]+1;
			wait10Msec(1);
		}

		if(joy2Btn(btn_B)&&servo[Drop]!=SCOOP_UP){
			setClamp(CLAMP_OPEN);
		} else if(servo[Drop]>SCOOP_LEVEL||servo[Drop]<SCOOP_LEVEL-20){
			setClamp(CLAMP_DOWN);
		}

		if(joystick.joy2_TopHat==2)
		{
			shift++;
			wait10Msec(3);
			} else if (joystick.joy2_TopHat==6) {
			shift--;
			wait10Msec(3);
		}
		if(servo[FlagTwist]!=FLAG_ARM_IN)
		{
			servo[FlagTwist]=FLAG_ARM_OUT+shift;
		}

		if(joy1Btn(btn_RB)&&out){
			StopTask(closeGrip);
			StopTask(fixStuff);
			StartTask(openGrip);
			} else if (joy1Btn(btn_LB)){
			StopTask(openGrip);
			StopTask(fixStuff);
			StopTask(closeGrip);
			servo[AlignServo2]=ALIGN_2_OUT;
			if(servo[AlignServo1]==ALIGN_1_IN)
			{
				wait10Msec(15);
			}
			servo[AlignServo1]=ALIGN_1_OUT;
			out=true;
			} else if (joy1Btn(btn_RT)&&servo[AlignServo1]!=ALIGN_1_IN&&servo[AlignServo2]!=ALIGN_2_IN){
			StopTask(openGrip);
			StopTask(fixStuff);
			StartTask(closeGrip);
			} else if (joy1Btn(btn_LT)&&servo[AlignServo1]!=ALIGN_1_IN&&servo[AlignServo2]!=ALIGN_2_IN){
			StopTask(openGrip);
			StopTask(closeGrip);
			StartTask(fixStuff);
		}
	}
}
